<style>
  circle {
      fill-opacity: 0.7;
  }
  circle:hover {
      fill-opacity: 1;
      fill: #ccc !important;
      stroke: #666 !important;
  }
  svg, body, html {
      font-family: Arial, sans-serif;
  }
  svg {
      background-color: #999;
      box-shadow: inset 0 0 20px #333;
      border-radius: 20px;
      display: inline-block;
      position: relative;
  }
  circle.activated {
      fill: #EE0 !important;
      stroke: #660 !important;
  }
  html, body, svg {
      margin: 0;
      padding: 0;
  }
  #graph, #controls {
      display: inline-block;
  }
  #graph {
      position: relative;
  }
  #controls {
      vertical-align: top;
      padding: 0em 1em 1em;
      border-radius: 20px;
      box-shadow: inset 0 0 8px #aaa;
      height: 100%;
  }
  #data {
      position: absolute; 
      bottom: 0;
      z-index: 1;
      padding: 0.4em 1em 1em;
      background-color: rgba(255, 255, 255, 0.65);
      border-bottom-left-radius: 20px;
      border-bottom-right-radius: 20px;
      width: 100%;
      box-sizing: border-box;
      text-align: center;
  }
  dt {
      font-weight: bold;
  }
  dd {
      margin-left: 0;
      font-size: 0.9em;
  }
  .label {
      position: absolute;
      display: none;
      border-radius: 4px;
      background-color: rgba(255, 255, 255, 0.65);
      padding: 0.6em;
  }
  .inline {
      display: inline-block;
      width: 33%;
      margin-bottom: 0.4em;
  }
</style>
<div id="graph">
    <div id="data" style="display: none;">
        <span class="inline"><dt>Category</dt><dd id="category"></dd></span>
        <span class="inline"><dt>Subcategory</dt><dd id="subcategory"></dd></span>
        <span class="inline"><dt>Stakeholders</dt><dd id="stakeholders"></dd></span>
        <dt>Idea</dt><dd id="idea"></dd>
    </div>
</div>
<div id="controls">
    <h2>Sort by:</h2>
    <ul>
        <li><input type="radio" name="sort" id="sortCat" value="category" checked="checked" /><label for="sortCat">Category</label></li>
        <li><input type="radio" name="sort" id="sortSubcat" value="subcategory" /><label for="sortSubcat">Subcategory</label></li>
        <li><input type="radio" name="sort" id="sortStake" value="stakeholders" /><label for="sortStake">Stakeholder</label></li>
    </ul>
    <h2>Color by:</h2>
    <ul>
        <li><input type="radio" name="color" id="colorCat" value="category" checked="checked" /><label for="colorCat">Category</label></li>
        <li><input type="radio" name="color" id="colorSubcat" value="subcategory" /><label for="colorSubcat">Subcategory</label></li>
        <li><input type="radio" name="color" id="colorDay" value="day" /><label for="colorDay">Day</label></li>
    </ul>
    <input type="checkbox" name="showLabels" id="showLabels" /><label for="showLabels">Show Labels</label><br />
    <input type="checkbox" name="veryDiffSubcatColors" id="veryDiffSubcatColors" /><label for="veryDiffSubcatColors">Very Different Subcategory Colors</label>
</div>
<script type="text/javascript">
    var sortAttr = 'category', colorAttr = 'category';

    var sizes = {
            'Micro': 10,
            'Meso': 10,
            'Macro': 10,
            'Research & Metrics': 10
        },
        subcatColorScaleFactor = 0.65,
        foci = {},
        retrievedData,
        catColorScale = d3.scale.category10(),
        dayColorScale = d3.scale.category10(),
        subcatColorScale = d3.scale.category10(),
        subcatColorsAreVeryDifferent = false,
        w,
        h;

    function getFoci(groups) {
        var fociStack = [],
            foci = {},
            numGroups = groups.length,
            perRow = Math.ceil(Math.sqrt(numGroups)),
            numRows = Math.ceil(Math.sqrt(numGroups)),
            numInRow;

        for(i=0; i < numRows; i++) {
            numInRow = Math.min(perRow, numGroups - (i * perRow));
            for(j=0; j < numInRow; j++) {
                fociStack.push(
                    [(w / (numInRow + 1)) * (j + 1), (h / (numRows + 1)) * (i + 1)]
                );
            }
        }

        for (i in groups) {
            foci[groups[i]] = fociStack.pop();
        }
        return foci;
    }

    function getCatColor(arg) {
        var sum = 0;
        for (i=0; i < arg.length; i++) {
            sum += arg.charCodeAt(i);
        }
        return sum;
    }

    function getColor(node) {
        switch(colorAttr) {
            case 'day':
                return d3.rgb(dayColorScale(node.day));
            case 'subcategory':
                // Evidently d3 has scales, which could probably do this for me
                if (subcatColorsAreVeryDifferent) {
                    return d3.rgb(subcatColorScale(getCatColor(node.subcategory.name)));
                } else {
                    var category = retrievedData.graph.categories.filter(function(cat) { return cat.name == node.category.name; })[0];
                    var colorDelta = (category.subcategories.map(function(s) { return s.name; }).indexOf(node.subcategory.name) - Math.floor(category.subcategories.length / 2)) * subcatColorScaleFactor;
                    return d3.rgb(subcatColorScale(getCatColor(node.category.name))).brighter(colorDelta); 
                }
            case 'category':
                return d3.rgb(catColorScale(getCatColor(node.category.name)));
        }
    }

    function getX(foci, node, index) {
        index = index || 0;
        xs = [];
        if (node[sortAttr] instanceof Array) {
            for (i in node[sortAttr]) {
                xs.push(foci[node[sortAttr][i].name][index]);
            }
        }
        else {
            xs.push(foci[node[sortAttr].name][index]);
        }
        return d3.mean(xs);
    }

    function getY(foci, node) {
        return getX(foci, node, 1);
    }

    function addLabels() {
        var groups = retrievedData.graph[sortAttr].map(function(s) { return s.name; });
        foci = getFoci(groups);
        var display = $('.label').css('display');
        $('.label').remove();
        for (i in groups) {
            $('<div />').appendTo('body').addClass('label').text(groups[i]).css({
                'left': /*$('svg').offset().left +*/ foci[groups[i]][0],
                'top': /*$('svg').offset().top +*/ foci[groups[i]][1],
                'display': display
            });
        }
    }

    $.getJSON('/graphs/<%= @graph.id %>.json', function(data) {

        var nodes = data.graph.ideas;
        w = $('body').width() * 0.7,
        h = $(window).height() * 0.995,
        $('#graph').width(w);

        retrievedData = data;

        // These are here so plurals aren't an issue when switching sorting
        retrievedData.graph.category = retrievedData.graph.categories;
        retrievedData.graph.subcategory = retrievedData.graph.subcategories;

        var vis = d3.select("#graph").append("svg:svg")
            .attr("width", w)
            .attr("height", h);

        foci = getFoci(data.graph[sortAttr].map(function(s) { return s.name; }));

        var force = d3.layout.force()
            .nodes(nodes)
            .links([])
            .size([w, h])
            .gravity(0)
            .theta(1.2)
            .charge(-6)
            .start();

        var node = vis.selectAll("circle.node")
            .data(nodes)
          .enter().append("svg:circle")
            .attr("class", "node")
            .attr("cx", function(d) { return getX(foci, d); })
            .attr("cy", function(d) { return getY(foci, d); })
            .attr("r", function(d) { return sizes[d.category.name]; })
            .style("fill", function(d, i) { return getColor(d); })
            .style("stroke", function(d, i) { return d3.rgb(getColor(d)).darker(2); })
            .style("stroke-width", 1.5);

        vis.style("opacity", 1e-6)
          .transition()
            .duration(1000)
            .style("opacity", 1);

        force.on("tick", function(e) {

         var k = .05 * e.alpha;
          nodes.forEach(function(o, i) {
            o.y += (getY(foci, o) - o.y) * k;
            o.x += (getX(foci, o) - o.x) * k;
          });

          vis.selectAll("circle.node")
              .attr("cx", function(d) { return d.x; })
              .attr("cy", function(d) { return d.y; })
        });

        d3.selectAll("circle.node").on("click", function(c) {
            d3.select(this).classed('activated', true);
            d3.select("#category").text(c.category.name);
            d3.select("#subcategory").text(c.subcategory.name);
            d3.select("#stakeholders").text(c.stakeholders.map(function(s) { return ' ' + s.name; }).toString());
            d3.select("#idea").text(c.content);
            $('#data').show();
            }).on("mouseout", function() { d3.select(this).classed('activated', false); $('#data').hide(); });

        addLabels();

        $('#showLabels').on("change", function(e) {
            $('.label').toggle();
        });

        $('#veryDiffSubcatColors').on('change', function(e) {
            subcatColorsAreVeryDifferent = $(this).is(':checked');
        });

        $("input[type=radio][name=sort]").on("change", function(e) {
            sortAttr = $(e.target).val();
            addLabels();
            force.start();
        });

        $("input[type=radio][name=color]").on("change", function(e) {
            d3.selectAll('circle.node')
                .transition().style("fill", function(d, i) { return getColor(d); })
                .transition().style("stroke", function(d, i) { return d3.rgb(getColor(d)).darker(2); });
            colorAttr = $(e.target).val();
            addLabels();
            force.start();
        });
    });
</script>
